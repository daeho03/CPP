스마트 포인터
	기존 포인터의 문제
		더 이상 포인터가 필요하지 않을 때 메모리를 해제해야 함
	unique_ptr
		직접 메모리 관리하는 것만큼 빠름
		RAII원칙에 잘 들어맞음
		포인터(원시 포인터라 부르자)를 단독으로 소유
		원시 포인터는 누구하고도 공유되지 않음
		scope를 벗어날 때, 지워짐
			delete를 쓸 필요가 없음
		c++ 14이전 문제
			원시 포인터 공유 가능
		c++ 14이후
			make_unique를 사용해서 unique_ptr을 생성
			std::make_unique
				주어진 매개변수와 자료형으로 new키워드를 호출해 줌
				따라서 원시 포인터와 같음
				둘 이상의 unique_ptr가 원시 포인터를 공유할 수 없도록 막음
		reset()
			포인터를 교체함
			unique_ptr가 재설정될 때, 소유하고 있던 원시 포인터는 자동으로 소멸
		get()
			원시 포인터를 반환
		relaese()
			원시 포인터에 대한 소유권을 박탈하고 원시 포인터를 반환
			release() 호출 후 get()을 호출하면 nullptr가 반환됨
		유니크 포인터의 원시 포인터 소유권 이전
			std::unipue_ptr는 소유한 원시 포인터를 공유하지 않음
			즉, 주소 복사를 하지 않는다는 뜻
			대신, 소유권을 다른 std::unique_ptr로 옮길 수 있음
			예외 : const std::unique_ptr
			std::move()
				개체 A의 모든 멤버를 포기하고 그 소유권을 B에게 주는 방법
				메모리 할당과 해제가 일어나지 않음
				간단하게, A에 있는 모든 포인터를 B에게 대입하고 A에는 nullptr를 넣는 것
				// 이게 어떻게 도는지는 나중에...
	shared_ptr
		std::shared_ptr를 배우기 전에, 자동 메모리 관리에 대해 설명
			주로 쓰는 두 가지 기법이 있음
				가비지 컬렉션(Garbage Collection), Java와 C#에서 지원
				참조 카운팅(Reference Counting), Swift와 애플  Objective-c에서 지원
				가비지 컬렉션
					보통 트레이싱 가비지 컬렉션을 의미
					메모리 누수를 막으려는 시도
					주기적으로 컬렉션 실행
					충분한 여유 메모리가 없을 때 컬렉션이 실행됨
						스케쥴에 따라 또는 수동으로도 실행가능
					매 주기마다, GC는 루트("root")를 확인함:
						전역 변수
						스택
						레지스터
					힙에 있는 개체에 루트를 통해 접근할 수 있는지 판단
					접근할 수 없다면, 가비지로 간주해서 해제