스마트 포인터
	기존 포인터의 문제
		더 이상 포인터가 필요하지 않을 때 메모리를 해제해야 함
	unique_ptr
		직접 메모리 관리하는 것만큼 빠름
		RAII원칙에 잘 들어맞음
		포인터(원시 포인터라 부르자)를 단독으로 소유
		원시 포인터는 누구하고도 공유되지 않음
		scope를 벗어날 때, 지워짐
			delete를 쓸 필요가 없음
		c++ 14이전 문제
			원시 포인터 공유 가능
		c++ 14이후
			make_unique를 사용해서 unique_ptr을 생성
			std::make_unique
				주어진 매개변수와 자료형으로 new키워드를 호출해 줌
				따라서 원시 포인터와 같음
				둘 이상의 unique_ptr가 원시 포인터를 공유할 수 없도록 막음
		reset()
			포인터를 교체함
			unique_ptr가 재설정될 때, 소유하고 있던 원시 포인터는 자동으로 소멸
		get()
			원시 포인터를 반환
		relaese()
			원시 포인터에 대한 소유권을 박탈하고 원시 포인터를 반환
			release() 호출 후 get()을 호출하면 nullptr가 반환됨
		유니크 포인터의 원시 포인터 소유권 이전
			std::unipue_ptr는 소유한 원시 포인터를 공유하지 않음
			즉, 주소 복사를 하지 않는다는 뜻
			대신, 소유권을 다른 std::unique_ptr로 옮길 수 있음
			예외 : const std::unique_ptr
			std::move()
				개체 A의 모든 멤버를 포기하고 그 소유권을 B에게 주는 방법
				메모리 할당과 해제가 일어나지 않음
				간단하게, A에 있는 모든 포인터를 B에게 대입하고 A에는 nullptr를 넣는 것
				// 이게 어떻게 도는지는 나중에...
	shared_ptr
		std::shared_ptr를 배우기 전에, 자동 메모리 관리에 대해 설명
			주로 쓰는 두 가지 기법이 있음
				가비지 컬렉션(Garbage Collection), Java와 C#에서 지원
				참조 카운팅(Reference Counting), Swift와 애플  Objective-c에서 지원
				가비지 컬렉션
					보통 트레이싱 가비지 컬렉션을 의미
					메모리 누수를 막으려는 시도
					주기적으로 컬렉션 실행
					충분한 여유 메모리가 없을 때 컬렉션이 실행됨
						스케쥴에 따라 또는 수동으로도 실행가능
					매 주기마다, GC는 루트("root")를 확인함:
						전역 변수
						스택
						레지스터
					힙에 있는 개체에 루트를 통해 접근할 수 있는지 판단
					접근할 수 없다면, 가비지로 간주해서 해제
					문제점
						사용되지 않는 메모리를 즉시 정리하지 않음
						GC가 메모리를 해제해야 하는지 판단하는 동안 애플리케이션이 멈추거나 버벅일 수 있음
				참조 카운팅
					가비지 컬렉션처럼, 개체에 대한 참조가 없을 때 개체가 해제됨
					언제든 참조 횟수를 활용해서 특정 개체가 몇 번이나 참조되고 있는지 판단 가능
					어떤 개체 A를 다른 개체 B가 참조할 때 A의 참조 횟수가 늘어남
					B가 참조를 그만둘 때 횟수가 줄어듦
						ex) B가 scope를 벗어나는 경우
			강한 참조
				강한 참조란 개체 A가 개체 B를 참조할 때, 개체 B는 절대 소멸되지 않음을 의미
				강한 참조의수를 저장하기 위해 강한 참조 카운트를 사용
				일반적으로 새 인스턴스, 즉 개체에 대한 참조를 만들 때 강한 참조 횟수가 늘어남
				강한 참조 횟수가 0이 될 때 해당 개체는 소멸됨
			참조 카운팅의 문제점
				참조 횟수는 너무 자주 바뀜
					멀티 쓰레드 환경에서 안전하려면, lock이나 원자적 연산이 필요
					++mRefCount보다 확연히 느림
				순환(circular) 참조
					개체 A가 개체 B를 참조
					개체 B가 개체 A를 참조
					해제되지 않음
			메모리 누수
				GC나 RefCount를 쓰면 전통적인 메모리 누수는 없음
					ex) delete
				여전히 메모리 누수가 발생할 수 있음
					ex) 순환 참조
			정리
				가비지 컬렉션
					사용하기 더 쉬움
					실시간 또는 고성능 프로그램에 적합하지 않음
				참조 카운팅
					여전히 사용하기 쉬움
					실시간 또는 고성능 프로그램에 적합
					멀티 스레드 환경에서는 순수한 포인터보다 훨씬 느림
		두 개의 포인터를 소유
			데이터(원시 포인터)를 가리키는 포인터
			제어 블록을 가리키는 포인터