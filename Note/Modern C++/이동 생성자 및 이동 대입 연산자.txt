값(value)의 분류
	lvalue
		단일 식을 넘어 지속되는 개체
			주소가 있음
			이름이 있는 변수
			const 변수
			배열 변수
			비트 필드
			공용 구조체
			...
	rvalue
		lavalue가 아닌 개체
		사용되는 단일 식을 넘어 지속되지 않는 일시적인 값
			주소가 없는 개체
			리터럴(문자열 리터럴 제외)
			참조로 반환하지 않는 함수 호출
			기본으로 지원되는 산술식, 논리식, 비교식
			열거형
			람다
			...
ravlue 참조 (&&)
	C++11 이루에 새로 나온 연산자
	기능상 & 연산자와 비슷
	& 연산자는 lvalue 참조에 사용
	&& 연산자는 rvalue 참조에 사용
std::move()
	rvalue 참조를 반환
	lvalue를 rvalue로 변환
이동 생성자
	<class_name::<class_name>(<class_name>&&)
		다른 개체 멤버 변수들의 소유권을 가져 옴
		복사 생성자와 달리, 메모리 재할당을 하지 않음
		복사 생성자보다 빠름
		얕은 복사와 비슷
이동 대입 연산자
	<class_name>& <class_name>::operator=(<class_name>&&)
		이동 생성자와 같은 개념
		다른 개체 멤버 변수들의 소유권을 가져 옴
		메모리 재할당을 하지 않음
		얕은 복사
C++11 이후로, STL 컨테이너에 이동 생성자와 이동  대입이 생김
	따로 구현할 필요 없음
rvalue 최적화
	이동 생성자와 이동 대입 연산자는 유효
	포인터 대신 개체 자체를 반환하는 함수
		함수에서 rvalue를 반환하는 것은 실제 매우 느림
		반환 값 최적화라고 하는 컴파일러 최적화를 깨뜨림
	베스트 프랙티스
		기본적으로 그냥 개체를 반환
		더 빨라진다고 입증된 경우에만 함수가 rvalue를 반환하도록 바꿀것