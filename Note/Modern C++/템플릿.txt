템플릿(Template) 프로그래밍
	예전 컴파일러 중에 >>에서 에러가 나는 경우가 있음
	템플릿
		java와 C#에서의 제네릭(generic) 메서드/클래스와 비슷
		STL 컨테이너 또한 템플릿
		코드를 자료형마다 중복으로 작성하지 않아도 됨
	함수 템플릿
		template <class <type_name>> <function_def;
		template <typename <type_name>> <function_def;
			typename과 class는 사실상 별 차이가 없음
		함수 템플릿을 호출할 때 템플릿 매개변수를 생략할 수 있음
		템플릿에 넣는 자료형 가짓수에 비례해서 exe 파일 크기 증가
		컴파일 타임에 어느정도 다형성을 부여할 수 있음 // 이거에 대해서는 뒤에서...
	클래스 템플릿
		구현파일은 헤더파일 안에 들어가야 한다
			각 cpp 파일은 따로 컴파일 되기 때문에(클래스 선언만 볼 수 있댜는 뜻) 컴파일러가 구현체를 볼 수 있어야 해서
		개체를 선언할 때 템플릿 매개변수를 명시해야 함
			함수는 호출할 때 매개변수에서 타입을 추측할 수 있지만 클래스는 안돼서
	두 개의 템플릿 매개변수
		template<class <type_name>, class <type_name>>
		template<typename <type_name>, typename <type_name>>
	템플릿 특수화(Specialization)
		특정한 템플릿 매개변수를 받도록 템플릿 코드를 커스터마이즈할 수 있음
		전체 템플릿 특수화, 부분 템플릿 특수화가 있음
	장점과 단점
		컴파일러가 컴파일 도중에 각 템플릿 인스턴스에 대한 코드를 만들어 줌
			컴파일 타임은 비교적 느림
			템플릿 매개변수를 추가할수록 더 느려짐
			하지만 런타임 속도는 더 빠를지도 모름
			실행 파일 크기가 커지기 때문에 항상 그런 것은 아님
			C#과 Java도 어느정도 해당되는 말(그래서 ArrayList를 쓰지 말라는 것)
		자료형만 다른 중복 코드를 없애는 훌륭한 방법
		하지만 쓸모없는 템플릿 변형을 막을 방법이 없음
			최대한 제네릭 함수를 짧게 유지할 것
			제네릭이 아니어도 되는 부분은 별도의 함수로 옮기는 것도 방법
		컴파일 도중에 다형성을 부여할 수 있음
			C++ 프로그래머가 많이 잘못 썼던 기능
			가상 테이블이 없어서 프로그램이 더 빠름
			하지만 exe 파일이 커지면 느려질 수 있음
	템플릿 프로그래밍 best practice
		컨테이너의 경우 매우 적합
			아주 다양한 형들을 저장할 수 있음
			그런 이유로 Java와 C# 제네릭이 주로 컨테이너에 쓰이는 것
		컨테이너가 아닌 경우
			각기 다른 서넛 이상의 자료형을 다룬다면 템플릿을 쓸 것
			두가지 정도라면 클래스를 2개 만들 것
STL 알고리듬(Algorithm)
	요소 범위에서 쓸 수 있는 함수들
	배열 또는 몇몇 STL 컨테이너에 쓸 수 있음
	반복자를 통해 컨테이너에 접근
	컨테이너의 크기를 변경하지 않음(따라서 추가 메모리 할당도 없음)