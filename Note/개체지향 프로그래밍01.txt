class
	기본 생성자(Constructor)
		기본 생성자는 매개변수를 받지 않음
		클래스에 생성자가 없으면 컴파일러가 기본 생성자를 자동적으로 만들어 줌
		이렇게 자동적으로 만들어진 생성자는
			멤버변수를 초기화하지 않음
			하지만 모든 포함된 개체의 생성자를 호출
		1. 클래스에서 생성자가 없는 경우
			매개변수가 없는 생성자를 만듦
		2. 클래스에 생성자가 있는 경우
			기본 생성자를 만들어 주지 않음
	소멸자(Destructor) : 클래스명 앞에 ~를 붙이면 됨
	const 멤버 함수
		함수 뒤에 const;
		해당 개체 안의 어떤 것도 바꾸지 않음
		멤버 변수가 변하는 것을 방지
	접근 제어자
		멤버변수 : 메소드 밖에서 선언된 변수를 말한다
			멤버변수 초기화 : java와 달리 0으로 초기화 하지 않음
			초기화 리스트
				멤버 변수를 대입 없이 초기화
				상수나 참조 변수도 초기화 가능
				생성자 뒤에 : 을 찍고 그 뒤에는 , 로
		public : 누구나 접근 가능
		protected : 자식 클래스에서 접근 가능
		private : 해당 클래스에서만 접근 가능
		보통 제어자 별로 C++ 멤버들을 그룹 지음
	개체 생성
		스택 메모리에 만들기 -> Vector a;
		스택
			예약된 로컬 메모리 공간(작음, 일반적으로 1MB 이하)
			함수 호출과 반환이 이 메모리에서 일어남
			단순히 스택 포인터를 옮김
				메모리를 할당 및 해제할 필요가 없음
				스택에 할당된 메모리는 범위(scope)를 벗어나면 사라짐
				변수와 매개변수를 위해 필요한 크기는 컴파일 도중에 알 수 있음
			하지만 스택에 큰 개체를 많이 넣으면
				스택 오버플로우가 발생할 수 있음
				성능이 느려 질 수도 있음
		힙 메모리에 만들기 -> Vector* b = new Vector();
		힙
			전역 메모리 공간(큼, ~GBs)
			비어 있고 연속된 메모리 블록을 찾아야 함
			프로그래머가 메모리를 직접 할당 및 해제해야 함
				그렇지 않으면, 메모리 누수 발생
				C++은 언매니지드 언어
		개체 배열(Array)
			10개의 벡터 개체를 힙에 만듦
				Vector* list = new Vector[10];
					Vector의 크기의 메모리를 10개 만드는것
			10개의 포인터를 힙에 만듦
				Vector** list = new Vector*[10];
		개체 소멸
			직접 지워줘야함
			delete 변수; 로 메모리를 즉시 해제
			변수 = NULL; 은 안 해도 됨
			배열은 delete[] 변수;
			메모리 누수 방지를 위해 delete가 필수
			java나 C#은 가비지 컬렉터가 해줌
				메모리는 나중에 해제될 수도 있음
	생성자 오버로딩(Overloading)
		여러 개의 생성자를 만들 수 있음
			같은 이름
			인자의 개수나 자료형은 다름
	소멸자(Destructor) //가상 소멸자에 대해선 나중에...
		개체가 지워질 때 호출됨
			new로 만든 개체면 delete로 지울 때
			스택에 만든 개체면 지워 질 때
	구조체와 클래스
		struct의 기본 접근권한 : public
		class의 기본 접근권한 : private
		C와 다르게 struct에서도 class기능을 다 쓸 수 있음
		컴퓨터는 구조체와 클래스를 구분 못 함
			어셈블리어 코드에서는 거의 동일하게 작동함
			컴파일러는 차이점을 안다.
		구조체에 관한 코딩표준
			C++에서는 구조체를 클래스처럼 쓸 수 있음
				하지만 절대 그러지 말 것
				구조체는 C스타일로 쓸 것
			struct는 순수하게 데이터뿐이여야 함(Plain Old Data, POD)
				사용자가 선언한 생성자나 소멸자 x
				static가 아닌 private/protected 멤버 변수 x
				가상 함수 x
				메모리 카피가 가능함
					memcpy()를 사용하여 struct를 char[]로, 혹은 반대로 복사할 수 있음