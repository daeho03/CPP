상속
	파생 클래스 정의
		class <derived class name> :  <access - modifier(접근 제어자)> <base class name> {};
		상속 시 베이스 클래스 멤버의 접근수준을 결정할 수 있다
			public 상속, privace 상속 , protected 상속
				대부분 public상속만 함
	상속의 조건
		is-a 관계가 성립되게 해야 함
		has-a(소유) 관계에 의한 상속
생성자 호출순서
	베이스 클래스의 생성자가 먼저 호출 됨
	그 다음으로 파생클래스의 생성자가 호출 됨
	부모 클래스의 특정 생성자를 호출 할 때는 초기화 리스트를 사용해야함
소멸자 호출순서
	파생 클래스의 소멸자가 먼저 호출 됨
	파생 클래스 소멸자의 마지막에서 베이스 클래스의 소멸자가 자동적으로 호출됨
다형성(polymorphism)
	멤버 함수의 메모리
		멤버 함수도 메모리 어딘가에 위치해 있음
			모든 것이 메모리 어딘가에 위치해 있어야 함
		각 개체마다 멤버 함수의 메모리가 잡혀있지 않음
			코드에서는 매개변수를 받지 않아도 실제 메모리를 보면 포인터를 받음
		각 멤버 함수는 컴파일 시에 딱 한 번만 메모리에 "할당"됨
	함수 오버라이딩
		Animal클래스에서 말하는 기능이 있다면 Cat클래스에 와서는 다르게 말하는것
			Animal class를 상속 받으면 말하는 함수는 있지만 실제 어느 말을 할 지는 자식 클래스가 결정하는 것
	정적 바인딩
		C++은 부모의 포인터로 자식을 가리키고 있을 때 자식 클래스에서 함수 오버라이딩을 했어도 부모의 함수가 호출 됨
			// Animal.cpp
			void Animal::Speak(){
				cout << "An animal is speaking" << endl;	
			}
			// Cat.cpp
			void Cat::Speak(){
				cout << "Meow" << endl;	
			}
			// main.cpp
			Cat* myCat = new Cat();
			MyCat->Speak(); // Meow를 출력
			Animal* youtCat = new Cat();
			yourCat->Speak(); // An animal is speaking를 출력
	가상(virtual) 함수
		함수 앞에 virtual키워드
		부모의 포인터 또는 참조를 사용 중이더라도 자식 클래스의 멤버함수가 언제나 호출 됨
		동적(dynamic) 바인딩/늦은 바인딩
			실행 중에 어떤 함수를 호출할지 결정한다
			당연히 정적 바인딩 보다 느림
		이를 위해 가상 테이블(가상 함수 테이블)이 생성됨
			모든 가상 멤버함수의 주소를 포함
			가상 테이블은 클래스 마다 하나 있다
			개체를 생성할 때, 해당 클래스의 가상 테이블 주소가 함께 저장됨
			점프 테이블 또는 룩업 테이블이라고도 불림
	가상 소멸자
		소멸자 앞에 virtual키워드
			가상 소멸자 안 만들면 메모리 누수가 생길 수 있음
		모든 클래스 소멸자를 가상 소멸자로 하는 것이 좋음(C++14/17에는 상속 받는것을 막을 방법이 있음)
		멤버함수의 가상성은 상속된다
		베이스 클래스에서 가상으로 선언된 멤버함수가 있다면
			파생 클래스에서 동일한 시그내처를 가진 함수 역시 가상함수
				virtual키워드가 안 붙어 있어도